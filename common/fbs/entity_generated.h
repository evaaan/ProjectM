// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_
#define FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace EntityBuffer {

struct Vec2;

struct TransformFbs;
struct TransformFbsBuilder;

struct DynamicFbs;
struct DynamicFbsBuilder;

struct KeyStateFbs;
struct KeyStateFbsBuilder;

struct PlayerFbs;
struct PlayerFbsBuilder;

struct ConnectionFbs;
struct ConnectionFbsBuilder;

struct EntityFbs;
struct EntityFbsBuilder;

enum BodyType {
  BodyType_Player = 0,
  BodyType_Transparent = 1,
  BodyType_Ledge = 2,
  BodyType_Solid = 3,
  BodyType_MIN = BodyType_Player,
  BodyType_MAX = BodyType_Solid
};

inline const BodyType (&EnumValuesBodyType())[4] {
  static const BodyType values[] = {
    BodyType_Player,
    BodyType_Transparent,
    BodyType_Ledge,
    BodyType_Solid
  };
  return values;
}

inline const char * const *EnumNamesBodyType() {
  static const char * const names[5] = {
    "Player",
    "Transparent",
    "Ledge",
    "Solid",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyType(BodyType e) {
  if (flatbuffers::IsOutRange(e, BodyType_Player, BodyType_Solid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBodyType()[index];
}

enum Data {
  Data_NONE = 0,
  Data_TransformFbs = 1,
  Data_DynamicFbs = 2,
  Data_KeyStateFbs = 3,
  Data_PlayerFbs = 4,
  Data_ConnectionFbs = 5,
  Data_MIN = Data_NONE,
  Data_MAX = Data_ConnectionFbs
};

inline const Data (&EnumValuesData())[6] {
  static const Data values[] = {
    Data_NONE,
    Data_TransformFbs,
    Data_DynamicFbs,
    Data_KeyStateFbs,
    Data_PlayerFbs,
    Data_ConnectionFbs
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[7] = {
    "NONE",
    "TransformFbs",
    "DynamicFbs",
    "KeyStateFbs",
    "PlayerFbs",
    "ConnectionFbs",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (flatbuffers::IsOutRange(e, Data_NONE, Data_ConnectionFbs)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<EntityBuffer::TransformFbs> {
  static const Data enum_value = Data_TransformFbs;
};

template<> struct DataTraits<EntityBuffer::DynamicFbs> {
  static const Data enum_value = Data_DynamicFbs;
};

template<> struct DataTraits<EntityBuffer::KeyStateFbs> {
  static const Data enum_value = Data_KeyStateFbs;
};

template<> struct DataTraits<EntityBuffer::PlayerFbs> {
  static const Data enum_value = Data_PlayerFbs;
};

template<> struct DataTraits<EntityBuffer::ConnectionFbs> {
  static const Data enum_value = Data_ConnectionFbs;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct TransformFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           verifier.EndTable();
  }
};

struct TransformFbsBuilder {
  typedef TransformFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_Y, y, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_HEIGHT, height, 0);
  }
  explicit TransformFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransformFbsBuilder &operator=(const TransformFbsBuilder &);
  flatbuffers::Offset<TransformFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformFbs> CreateTransformFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int32_t width = 0,
    int32_t height = 0) {
  TransformFbsBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct DynamicFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DynamicFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_POS = 8,
    VT_PREV_POS = 10,
    VT_VEL = 12,
    VT_ACCEL = 14
  };
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  const EntityBuffer::Vec2 *pos() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_POS);
  }
  const EntityBuffer::Vec2 *prev_pos() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_PREV_POS);
  }
  const EntityBuffer::Vec2 *vel() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_VEL);
  }
  const EntityBuffer::Vec2 *accel() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_ACCEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_POS) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_PREV_POS) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_VEL) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_ACCEL) &&
           verifier.EndTable();
  }
};

struct DynamicFbsBuilder {
  typedef DynamicFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(float width) {
    fbb_.AddElement<float>(DynamicFbs::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(DynamicFbs::VT_HEIGHT, height, 0.0f);
  }
  void add_pos(const EntityBuffer::Vec2 *pos) {
    fbb_.AddStruct(DynamicFbs::VT_POS, pos);
  }
  void add_prev_pos(const EntityBuffer::Vec2 *prev_pos) {
    fbb_.AddStruct(DynamicFbs::VT_PREV_POS, prev_pos);
  }
  void add_vel(const EntityBuffer::Vec2 *vel) {
    fbb_.AddStruct(DynamicFbs::VT_VEL, vel);
  }
  void add_accel(const EntityBuffer::Vec2 *accel) {
    fbb_.AddStruct(DynamicFbs::VT_ACCEL, accel);
  }
  explicit DynamicFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DynamicFbsBuilder &operator=(const DynamicFbsBuilder &);
  flatbuffers::Offset<DynamicFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DynamicFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<DynamicFbs> CreateDynamicFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    const EntityBuffer::Vec2 *pos = 0,
    const EntityBuffer::Vec2 *prev_pos = 0,
    const EntityBuffer::Vec2 *vel = 0,
    const EntityBuffer::Vec2 *accel = 0) {
  DynamicFbsBuilder builder_(_fbb);
  builder_.add_accel(accel);
  builder_.add_vel(vel);
  builder_.add_prev_pos(prev_pos);
  builder_.add_pos(pos);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct KeyStateFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyStateFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITSET = 4
  };
  uint64_t bitset() const {
    return GetField<uint64_t>(VT_BITSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BITSET) &&
           verifier.EndTable();
  }
};

struct KeyStateFbsBuilder {
  typedef KeyStateFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bitset(uint64_t bitset) {
    fbb_.AddElement<uint64_t>(KeyStateFbs::VT_BITSET, bitset, 0);
  }
  explicit KeyStateFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyStateFbsBuilder &operator=(const KeyStateFbsBuilder &);
  flatbuffers::Offset<KeyStateFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyStateFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyStateFbs> CreateKeyStateFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t bitset = 0) {
  KeyStateFbsBuilder builder_(_fbb);
  builder_.add_bitset(bitset);
  return builder_.Finish();
}

struct PlayerFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OWNER = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool owner() const {
    return GetField<uint8_t>(VT_OWNER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_OWNER) &&
           verifier.EndTable();
  }
};

struct PlayerFbsBuilder {
  typedef PlayerFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(PlayerFbs::VT_ID, id, 0);
  }
  void add_owner(bool owner) {
    fbb_.AddElement<uint8_t>(PlayerFbs::VT_OWNER, static_cast<uint8_t>(owner), 0);
  }
  explicit PlayerFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerFbsBuilder &operator=(const PlayerFbsBuilder &);
  flatbuffers::Offset<PlayerFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerFbs> CreatePlayerFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    bool owner = false) {
  PlayerFbsBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_owner(owner);
  return builder_.Finish();
}

struct ConnectionFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectionFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_USERNAME = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *username() const {
    return GetPointer<const flatbuffers::String *>(VT_USERNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_USERNAME) &&
           verifier.VerifyString(username()) &&
           verifier.EndTable();
  }
};

struct ConnectionFbsBuilder {
  typedef ConnectionFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ConnectionFbs::VT_ID, id, 0);
  }
  void add_username(flatbuffers::Offset<flatbuffers::String> username) {
    fbb_.AddOffset(ConnectionFbs::VT_USERNAME, username);
  }
  explicit ConnectionFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConnectionFbsBuilder &operator=(const ConnectionFbsBuilder &);
  flatbuffers::Offset<ConnectionFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectionFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectionFbs> CreateConnectionFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> username = 0) {
  ConnectionFbsBuilder builder_(_fbb);
  builder_.add_username(username);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectionFbs> CreateConnectionFbsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *username = nullptr) {
  auto username__ = username ? _fbb.CreateString(username) : 0;
  return EntityBuffer::CreateConnectionFbs(
      _fbb,
      id,
      username__);
}

struct EntityFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyVector(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyDataVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct EntityFbsBuilder {
  typedef EntityFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(EntityFbs::VT_ID, id, 0);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(EntityFbs::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(EntityFbs::VT_DATA, data);
  }
  explicit EntityFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityFbsBuilder &operator=(const EntityFbsBuilder &);
  flatbuffers::Offset<EntityFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityFbs> CreateEntityFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  EntityFbsBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityFbs> CreateEntityFbsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  auto data_type__ = data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0;
  return EntityBuffer::CreateEntityFbs(
      _fbb,
      id,
      data_type__,
      data__);
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_TransformFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::TransformFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_DynamicFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::DynamicFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_KeyStateFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::KeyStateFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_PlayerFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::PlayerFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_ConnectionFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::ConnectionFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const EntityBuffer::EntityFbs *GetEntityFbs(const void *buf) {
  return flatbuffers::GetRoot<EntityBuffer::EntityFbs>(buf);
}

inline const EntityBuffer::EntityFbs *GetSizePrefixedEntityFbs(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EntityBuffer::EntityFbs>(buf);
}

inline bool VerifyEntityFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EntityBuffer::EntityFbs>(nullptr);
}

inline bool VerifySizePrefixedEntityFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EntityBuffer::EntityFbs>(nullptr);
}

inline void FinishEntityFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EntityBuffer::EntityFbs> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEntityFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EntityBuffer::EntityFbs> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace EntityBuffer

#endif  // FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_
