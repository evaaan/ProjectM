// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_
#define FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace EntityBuffer {

struct Vec2;

struct TransformFbs;
struct TransformFbsBuilder;

struct DynamicFbs;
struct DynamicFbsBuilder;

struct InputFbs;
struct InputFbsBuilder;

struct PlayerFbs;
struct PlayerFbsBuilder;

struct EntityFbs;
struct EntityFbsBuilder;

enum BodyType {
  BodyType_Player = 0,
  BodyType_Transparent = 1,
  BodyType_Ledge = 2,
  BodyType_Solid = 3,
  BodyType_MIN = BodyType_Player,
  BodyType_MAX = BodyType_Solid
};

inline const BodyType (&EnumValuesBodyType())[4] {
  static const BodyType values[] = {
    BodyType_Player,
    BodyType_Transparent,
    BodyType_Ledge,
    BodyType_Solid
  };
  return values;
}

inline const char * const *EnumNamesBodyType() {
  static const char * const names[5] = {
    "Player",
    "Transparent",
    "Ledge",
    "Solid",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyType(BodyType e) {
  if (flatbuffers::IsOutRange(e, BodyType_Player, BodyType_Solid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBodyType()[index];
}

enum Data {
  Data_NONE = 0,
  Data_TransformFbs = 1,
  Data_DynamicFbs = 2,
  Data_InputFbs = 3,
  Data_PlayerFbs = 4,
  Data_MIN = Data_NONE,
  Data_MAX = Data_PlayerFbs
};

inline const Data (&EnumValuesData())[5] {
  static const Data values[] = {
    Data_NONE,
    Data_TransformFbs,
    Data_DynamicFbs,
    Data_InputFbs,
    Data_PlayerFbs
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[6] = {
    "NONE",
    "TransformFbs",
    "DynamicFbs",
    "InputFbs",
    "PlayerFbs",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (flatbuffers::IsOutRange(e, Data_NONE, Data_PlayerFbs)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<EntityBuffer::TransformFbs> {
  static const Data enum_value = Data_TransformFbs;
};

template<> struct DataTraits<EntityBuffer::DynamicFbs> {
  static const Data enum_value = Data_DynamicFbs;
};

template<> struct DataTraits<EntityBuffer::InputFbs> {
  static const Data enum_value = Data_InputFbs;
};

template<> struct DataTraits<EntityBuffer::PlayerFbs> {
  static const Data enum_value = Data_PlayerFbs;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct TransformFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           verifier.EndTable();
  }
};

struct TransformFbsBuilder {
  typedef TransformFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_Y, y, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(TransformFbs::VT_HEIGHT, height, 0);
  }
  explicit TransformFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransformFbsBuilder &operator=(const TransformFbsBuilder &);
  flatbuffers::Offset<TransformFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformFbs> CreateTransformFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int32_t width = 0,
    int32_t height = 0) {
  TransformFbsBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct DynamicFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DynamicFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_POS = 8,
    VT_PREV_POS = 10,
    VT_VEL = 12,
    VT_ACCEL = 14
  };
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  const EntityBuffer::Vec2 *pos() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_POS);
  }
  const EntityBuffer::Vec2 *prev_pos() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_PREV_POS);
  }
  const EntityBuffer::Vec2 *vel() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_VEL);
  }
  const EntityBuffer::Vec2 *accel() const {
    return GetStruct<const EntityBuffer::Vec2 *>(VT_ACCEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_POS) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_PREV_POS) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_VEL) &&
           VerifyField<EntityBuffer::Vec2>(verifier, VT_ACCEL) &&
           verifier.EndTable();
  }
};

struct DynamicFbsBuilder {
  typedef DynamicFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(float width) {
    fbb_.AddElement<float>(DynamicFbs::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(DynamicFbs::VT_HEIGHT, height, 0.0f);
  }
  void add_pos(const EntityBuffer::Vec2 *pos) {
    fbb_.AddStruct(DynamicFbs::VT_POS, pos);
  }
  void add_prev_pos(const EntityBuffer::Vec2 *prev_pos) {
    fbb_.AddStruct(DynamicFbs::VT_PREV_POS, prev_pos);
  }
  void add_vel(const EntityBuffer::Vec2 *vel) {
    fbb_.AddStruct(DynamicFbs::VT_VEL, vel);
  }
  void add_accel(const EntityBuffer::Vec2 *accel) {
    fbb_.AddStruct(DynamicFbs::VT_ACCEL, accel);
  }
  explicit DynamicFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DynamicFbsBuilder &operator=(const DynamicFbsBuilder &);
  flatbuffers::Offset<DynamicFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DynamicFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<DynamicFbs> CreateDynamicFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    const EntityBuffer::Vec2 *pos = 0,
    const EntityBuffer::Vec2 *prev_pos = 0,
    const EntityBuffer::Vec2 *vel = 0,
    const EntityBuffer::Vec2 *accel = 0) {
  DynamicFbsBuilder builder_(_fbb);
  builder_.add_accel(accel);
  builder_.add_vel(vel);
  builder_.add_prev_pos(prev_pos);
  builder_.add_pos(pos);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct InputFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITSET = 4
  };
  uint64_t bitset() const {
    return GetField<uint64_t>(VT_BITSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BITSET) &&
           verifier.EndTable();
  }
};

struct InputFbsBuilder {
  typedef InputFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bitset(uint64_t bitset) {
    fbb_.AddElement<uint64_t>(InputFbs::VT_BITSET, bitset, 0);
  }
  explicit InputFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputFbsBuilder &operator=(const InputFbsBuilder &);
  flatbuffers::Offset<InputFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputFbs> CreateInputFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t bitset = 0) {
  InputFbsBuilder builder_(_fbb);
  builder_.add_bitset(bitset);
  return builder_.Finish();
}

struct PlayerFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HP = 4,
    VT_MANA = 6
  };
  int16_t hp() const {
    return GetField<int16_t>(VT_HP, 0);
  }
  int16_t mana() const {
    return GetField<int16_t>(VT_MANA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_HP) &&
           VerifyField<int16_t>(verifier, VT_MANA) &&
           verifier.EndTable();
  }
};

struct PlayerFbsBuilder {
  typedef PlayerFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hp(int16_t hp) {
    fbb_.AddElement<int16_t>(PlayerFbs::VT_HP, hp, 0);
  }
  void add_mana(int16_t mana) {
    fbb_.AddElement<int16_t>(PlayerFbs::VT_MANA, mana, 0);
  }
  explicit PlayerFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerFbsBuilder &operator=(const PlayerFbsBuilder &);
  flatbuffers::Offset<PlayerFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerFbs> CreatePlayerFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t hp = 0,
    int16_t mana = 0) {
  PlayerFbsBuilder builder_(_fbb);
  builder_.add_mana(mana);
  builder_.add_hp(hp);
  return builder_.Finish();
}

struct EntityFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityFbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  EntityBuffer::Data data_type() const {
    return static_cast<EntityBuffer::Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const EntityBuffer::TransformFbs *data_as_TransformFbs() const {
    return data_type() == EntityBuffer::Data_TransformFbs ? static_cast<const EntityBuffer::TransformFbs *>(data()) : nullptr;
  }
  const EntityBuffer::DynamicFbs *data_as_DynamicFbs() const {
    return data_type() == EntityBuffer::Data_DynamicFbs ? static_cast<const EntityBuffer::DynamicFbs *>(data()) : nullptr;
  }
  const EntityBuffer::InputFbs *data_as_InputFbs() const {
    return data_type() == EntityBuffer::Data_InputFbs ? static_cast<const EntityBuffer::InputFbs *>(data()) : nullptr;
  }
  const EntityBuffer::PlayerFbs *data_as_PlayerFbs() const {
    return data_type() == EntityBuffer::Data_PlayerFbs ? static_cast<const EntityBuffer::PlayerFbs *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const EntityBuffer::TransformFbs *EntityFbs::data_as<EntityBuffer::TransformFbs>() const {
  return data_as_TransformFbs();
}

template<> inline const EntityBuffer::DynamicFbs *EntityFbs::data_as<EntityBuffer::DynamicFbs>() const {
  return data_as_DynamicFbs();
}

template<> inline const EntityBuffer::InputFbs *EntityFbs::data_as<EntityBuffer::InputFbs>() const {
  return data_as_InputFbs();
}

template<> inline const EntityBuffer::PlayerFbs *EntityFbs::data_as<EntityBuffer::PlayerFbs>() const {
  return data_as_PlayerFbs();
}

struct EntityFbsBuilder {
  typedef EntityFbs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(EntityFbs::VT_ID, id, 0);
  }
  void add_data_type(EntityBuffer::Data data_type) {
    fbb_.AddElement<uint8_t>(EntityFbs::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(EntityFbs::VT_DATA, data);
  }
  explicit EntityFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityFbsBuilder &operator=(const EntityFbsBuilder &);
  flatbuffers::Offset<EntityFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityFbs> CreateEntityFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    EntityBuffer::Data data_type = EntityBuffer::Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  EntityFbsBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_id(id);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_TransformFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::TransformFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_DynamicFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::DynamicFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_InputFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::InputFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_PlayerFbs: {
      auto ptr = reinterpret_cast<const EntityBuffer::PlayerFbs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const EntityBuffer::EntityFbs *GetEntityFbs(const void *buf) {
  return flatbuffers::GetRoot<EntityBuffer::EntityFbs>(buf);
}

inline const EntityBuffer::EntityFbs *GetSizePrefixedEntityFbs(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EntityBuffer::EntityFbs>(buf);
}

inline bool VerifyEntityFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EntityBuffer::EntityFbs>(nullptr);
}

inline bool VerifySizePrefixedEntityFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EntityBuffer::EntityFbs>(nullptr);
}

inline void FinishEntityFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EntityBuffer::EntityFbs> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEntityFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EntityBuffer::EntityFbs> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace EntityBuffer

#endif  // FLATBUFFERS_GENERATED_ENTITY_ENTITYBUFFER_H_
